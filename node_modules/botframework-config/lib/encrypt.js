"use strict";
/**
 * @module botframework-config
 */
/**
 * Copyright(c) Microsoft Corporation.All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
/**
 * @private
 */
function generateKey() {
    // Generates 32 byte cryptographically strong pseudo-random data as a base64 encoded string
    // https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback
    return crypto.randomBytes(32).toString('base64');
}
exports.generateKey = generateKey;
/**
 * @private
 * Encrypt a string using standardized encyryption of AES256
 * @param plainText value to encrypt
 * @param secret secret to use
 */
function encryptString(plainText, secret) {
    if (!plainText || plainText.length === 0) {
        return plainText;
    }
    if (!secret || secret.length === 0) {
        throw new Error('you must pass a secret');
    }
    const keyBytes = Buffer.from(secret, 'base64');
    // Generates 16 byte cryptographically strong pseudo-random data as IV
    // https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback
    const ivBytes = crypto.randomBytes(16);
    const ivText = ivBytes.toString('base64');
    // encrypt using aes256 iv + key + plainText = encryptedText
    const cipher = crypto.createCipheriv('aes256', keyBytes, ivBytes);
    let encryptedValue = cipher.update(plainText, 'utf8', 'base64');
    encryptedValue += cipher.final('base64');
    // store base64(ivBytes)!base64(encryptedValue)
    return `${ivText}!${encryptedValue}`;
}
exports.encryptString = encryptString;
/**
 * @private
 * Decrypt a string using standardized encyryption of AES256
 * @param enryptedValue value to decrypt
 * @param secret secret to use
 */
function decryptString(encryptedValue, secret) {
    if (!encryptedValue || encryptedValue.length === 0) {
        return encryptedValue;
    }
    if (!secret || secret.length === 0) {
        throw new Error('you must pass a secret');
    }
    // enrypted value = base64(ivBytes)!base64(encryptedValue)
    const parts = encryptedValue.split('!');
    if (parts.length !== 2) {
        throw new Error('The encrypted value is not a valid format');
    }
    const ivText = parts[0];
    const encryptedText = parts[1];
    const ivBytes = Buffer.from(ivText, 'base64');
    const keyBytes = Buffer.from(secret, 'base64');
    if (ivBytes.length !== 16) {
        throw new Error('The encrypted value is not a valid format');
    }
    if (keyBytes.length !== 32) {
        throw new Error('The secret is not valid format');
    }
    // decrypt using aes256 iv + key + encryptedText = decryptedText
    const decipher = crypto.createDecipheriv('aes256', keyBytes, ivBytes);
    let value = decipher.update(encryptedText, 'base64', 'utf8');
    value += decipher.final('utf8');
    return value;
}
exports.decryptString = decryptString;
/**
 * @private
 * @param encryptedValue
 * @param secret
 */
function legacyDecrypt(encryptedValue, secret) {
    // LEGACY for pre standardized SHA256 encryption, this uses some undocumented nodejs MD5 hash internally and is deprecated
    const decipher = crypto.createDecipher('aes192', secret);
    let value = decipher.update(encryptedValue, 'hex', 'utf8');
    value += decipher.final('utf8');
    return value;
}
exports.legacyDecrypt = legacyDecrypt;
//# sourceMappingURL=encrypt.js.map