"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright(c) Microsoft Corporation.All rights reserved.
 * Licensed under the MIT License.
 */
const fsx = require("fs-extra");
const path = require("path");
const process = require("process");
const txtfile = require("read-text-file");
const util = require("util");
const uuid = require("uuid");
const botConfigurationBase_1 = require("./botConfigurationBase");
const encrypt = require("./encrypt");
const schema_1 = require("./schema");
// tslint:disable-next-line:no-var-requires no-require-imports
const exec = util.promisify(require('child_process').exec);
/**
 * BotConfiguration represents configuration information for a bot.
 *
 * @remarks
 * It is typically loaded from a .bot file on disk. This class implements methods for encrypting
 * and manipulating the in-memory representation of the configuration.
 */
class BotConfiguration extends botConfigurationBase_1.BotConfigurationBase {
    constructor() {
        super(...arguments);
        this.internal = {};
    }
    /**
     * Returns a new BotConfiguration instance given a JSON based configuration.
     * @param source JSON based configuration.
     */
    static fromJSON(source = {}) {
        // tslint:disable-next-line:prefer-const
        const services = (source.services) ? source.services.slice().map(botConfigurationBase_1.BotConfigurationBase.serviceFromJSON) : [];
        const botConfig = new BotConfiguration();
        Object.assign(botConfig, source);
        // back compat for secretKey rename
        if (!botConfig.padlock && botConfig.secretKey) {
            botConfig.padlock = botConfig.secretKey;
            delete botConfig.secretKey;
        }
        botConfig.services = services;
        botConfig.migrateData();
        return botConfig;
    }
    /**
     * Load the bot configuration by looking in a folder and loading the first .bot file in the
     * folder.
     * @param folder (Optional) folder to look for bot files. If not specified the current working directory is used.
     * @param secret (Optional) secret used to decrypt the bot file.
     */
    static loadBotFromFolder(folder, secret) {
        return __awaiter(this, void 0, void 0, function* () {
            folder = folder || process.cwd();
            let files = yield fsx.readdir(folder);
            files = files.sort();
            for (const file of files) {
                if (path.extname(file) === '.bot') {
                    return yield BotConfiguration.load(`${folder}/${file}`, secret);
                }
            }
            throw new Error(`Error: no bot file found in ${folder}. Choose a different location or use msbot init to create a .bot file."`);
        });
    }
    /**
     * Load the bot configuration by looking in a folder and loading the first .bot file in the
     * folder. (blocking)
     * @param folder (Optional) folder to look for bot files. If not specified the current working directory is used.
     * @param secret (Optional) secret used to decrypt the bot file.
     */
    static loadBotFromFolderSync(folder, secret) {
        folder = folder || process.cwd();
        let files = fsx.readdirSync(folder);
        files = files.sort();
        for (const file of files) {
            if (path.extname(file) === '.bot') {
                return BotConfiguration.loadSync(`${folder}/${file}`, secret);
            }
        }
        throw new Error(`Error: no bot file found in ${folder}. Choose a different location or use msbot init to create a .bot file."`);
    }
    /**
     * Load the configuration from a .bot file.
     * @param botpath Path to bot file.
     * @param secret (Optional) secret used to decrypt the bot file.
     */
    static load(botpath, secret) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield txtfile.read(botpath);
            const bot = BotConfiguration.internalLoad(json, secret);
            bot.internal.location = botpath;
            return bot;
        });
    }
    /**
     * Load the configuration from a .bot file. (blocking)
     * @param botpath Path to bot file.
     * @param secret (Optional) secret used to decrypt the bot file.
     */
    static loadSync(botpath, secret) {
        const json = txtfile.readSync(botpath);
        const bot = BotConfiguration.internalLoad(json, secret);
        bot.internal.location = botpath;
        return bot;
    }
    /**
     * Generate a new key suitable for encrypting.
     */
    static generateKey() {
        return encrypt.generateKey();
    }
    static internalLoad(json, secret) {
        const bot = BotConfiguration.fromJSON(JSON.parse(json));
        const hasSecret = !!bot.padlock;
        if (hasSecret) {
            bot.decrypt(secret);
        }
        return bot;
    }
    /**
     * Save the configuration to a .bot file.
     * @param botpath Path to bot file.
     * @param secret (Optional) secret used to encrypt the bot file.
     */
    saveAs(botpath, secret) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!botpath) {
                throw new Error(`missing path`);
            }
            this.internal.location = botpath;
            this.savePrep(secret);
            const hasSecret = !!this.padlock;
            if (hasSecret) {
                this.encrypt(secret);
            }
            yield fsx.writeJson(botpath, this.toJSON(), { spaces: 4 });
            if (hasSecret) {
                this.decrypt(secret);
            }
        });
    }
    /**
     * Save the configuration to a .bot file. (blocking)
     * @param botpath Path to bot file.
     * @param secret (Optional) secret used to encrypt the bot file.
     */
    saveAsSync(botpath, secret) {
        if (!botpath) {
            throw new Error(`missing path`);
        }
        this.internal.location = botpath;
        this.savePrep(secret);
        const hasSecret = !!this.padlock;
        if (hasSecret) {
            this.encrypt(secret);
        }
        fsx.writeJsonSync(botpath, this.toJSON(), { spaces: 4 });
        if (hasSecret) {
            this.decrypt(secret);
        }
    }
    /**
     * Save the file with secret.
     * @param secret (Optional) secret used to encrypt the bot file.
     */
    save(secret) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.saveAs(this.internal.location, secret);
        });
    }
    /**
     * Save the file with secret. (blocking)
     * @param secret (Optional) secret used to encrypt the bot file.
     */
    saveSync(secret) {
        return this.saveAsSync(this.internal.location, secret);
    }
    /**
     * Clear secret.
     */
    clearSecret() {
        this.padlock = '';
    }
    /**
     * Encrypt all values in the in memory config.
     * @param secret Secret to encrypt.
     */
    encrypt(secret) {
        this.validateSecret(secret);
        for (const service of this.services) {
            service.encrypt(secret, encrypt.encryptString);
        }
    }
    /**
     * Decrypt all values in the in memory config.
     * @param secret Secret to decrypt.
     */
    decrypt(secret) {
        try {
            this.validateSecret(secret);
            for (const connected_service of this.services) {
                connected_service.decrypt(secret, encrypt.decryptString);
            }
        }
        catch (err) {
            try {
                // legacy decryption
                this.padlock = encrypt.legacyDecrypt(this.padlock, secret);
                this.clearSecret();
                this.version = '2.0';
                const encryptedProperties = {
                    abs: [],
                    endpoint: ['appPassword'],
                    luis: ['authoringKey', 'subscriptionKey'],
                    dispatch: ['authoringKey', 'subscriptionKey'],
                    file: [],
                    qna: ['subscriptionKey']
                };
                for (const service of this.services) {
                    for (const prop of encryptedProperties[service.type]) {
                        const val = service[prop];
                        service[prop] = encrypt.legacyDecrypt(val, secret);
                    }
                }
                // assign new ids
                // map old ids -> new Ids
                const map = {};
                const oldServices = this.services;
                this.services = [];
                for (const oldService of oldServices) {
                    // connecting causes new ids to be created
                    const newServiceId = this.connectService(oldService);
                    map[oldService.id] = newServiceId;
                }
                // fix up dispatch serviceIds to new ids
                for (const service of this.services) {
                    if (service.type === schema_1.ServiceTypes.Dispatch) {
                        const dispatch = service;
                        for (let i = 0; i < dispatch.serviceIds.length; i++) {
                            dispatch.serviceIds[i] = map[dispatch.serviceIds[i]];
                        }
                    }
                }
            }
            catch (err2) {
                throw err;
            }
        }
    }
    /**
     * Return the path that this config was loaded from.  .save() will save to this path.
     */
    getPath() {
        return this.internal.location;
    }
    /**
     * Make sure secret is correct by decrypting the secretKey with it.
     * @param secret Secret to use.
     */
    validateSecret(secret) {
        if (!secret) {
            throw new Error('You are attempting to perform an operation which needs access to the secret and --secret is missing');
        }
        try {
            if (!this.padlock || this.padlock.length === 0) {
                // if no key, create a guid and enrypt that to use as secret validator
                this.padlock = encrypt.encryptString(uuid(), secret);
            }
            else {
                // validate we can decrypt the padlock, this tells us we have the correct secret for the rest of the file.
                encrypt.decryptString(this.padlock, secret);
            }
        }
        catch (ex) {
            throw new Error('You are attempting to perform an operation which needs access to the secret and --secret is incorrect.');
        }
    }
    savePrep(secret) {
        if (!!secret) {
            this.validateSecret(secret);
        }
        // make sure that all dispatch serviceIds still match services that are in the bot
        for (const service of this.services) {
            if (service.type === schema_1.ServiceTypes.Dispatch) {
                const dispatchService = service;
                const validServices = [];
                for (const dispatchServiceId of dispatchService.serviceIds) {
                    for (const this_service of this.services) {
                        if (this_service.id === dispatchServiceId) {
                            validServices.push(dispatchServiceId);
                        }
                    }
                }
                dispatchService.serviceIds = validServices;
            }
        }
    }
}
exports.BotConfiguration = BotConfiguration;
// Make sure the internal field is not included in JSON representation.
Object.defineProperty(BotConfiguration.prototype, 'internal', { enumerable: false, writable: true });
//# sourceMappingURL=botConfiguration.js.map