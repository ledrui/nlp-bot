"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const entities = require("html-entities");
const request = require("request-promise-native");
const pjson = require('../package.json');
const os = require("os");
const QNAMAKER_TRACE_TYPE = 'https://www.qnamaker.ai/schemas/trace';
const QNAMAKER_TRACE_NAME = 'QnAMaker';
const QNAMAKER_TRACE_LABEL = 'QnAMaker Trace';
/**
 * @private
 */
const htmlentities = new entities.AllHtmlEntities();
/**
 * Query a QnA Maker knowledge base for answers.
 *
 * @remarks
 * This class is used to make queries to a single QnA Maker knowledge base and return the result.
 *
 * Use this to process incoming messages with the [getAnswers()](#getAnswers) method.
 */
class QnAMaker {
    /**
     * Creates a new QnAMaker instance.
     * @param endpoint The endpoint of the knowledge base to query.
     * @param options (Optional) additional settings used to configure the instance.
     */
    constructor(endpoint, options = {}) {
        this.endpoint = endpoint;
        const { scoreThreshold = 0.3, top = 1, strictFilters = [], metadataBoost = [] } = options;
        this._options = {
            scoreThreshold,
            top,
            strictFilters,
            metadataBoost
        };
    }
    /**
     * Calls [generateAnswer()](#generateanswer) and sends the resulting answer as a reply to the user.
     *
     * @remarks
     * Returns a value of `true` if an answer was found and sent. If multiple answers are
     * returned the first one will be delivered.
     * @param context Context for the current turn of conversation with the user.
     */
    answer(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { top, scoreThreshold } = this._options;
            const answers = yield this.generateAnswer(context.activity.text, top, scoreThreshold);
            yield this.emitTraceInfo(context, answers);
            if (answers.length > 0) {
                yield context.sendActivity({ text: answers[0].answer, type: 'message' });
                return true;
            }
            return false;
        });
    }
    /**
     * Calls the QnA Maker service to generate answer(s) for a question.
     *
     * @deprecated  Instead, favor using [QnAMaker.getAnswers()](#getAnswers) to generate answers for a question.
     *
     * @remarks
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * @param question The question to answer.
     * @param top (Optional) number of answers to return. Defaults to a value of `1`.
     * @param scoreThreshold (Optional) minimum answer score needed to be considered a match to questions. Defaults to a value of `0.001`.
     */
    generateAnswer(question, top, scoreThreshold) {
        return __awaiter(this, void 0, void 0, function* () {
            const trimmedAnswer = question ? question.trim() : '';
            if (trimmedAnswer.length > 0) {
                const answers = yield this.callService(this.endpoint, question, typeof top === 'number' ? top : 1);
                const minScore = typeof scoreThreshold === 'number' ? scoreThreshold : 0.001;
                return answers.filter((ans) => ans.score >= minScore).sort((a, b) => b.score - a.score);
            }
            return [];
        });
    }
    /**
     * Calls the QnA Maker service to generate answer(s) for a question.
     *
     * @remarks
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * In addition to returning the results from QnA Maker, [getAnswers()](#getAnswers) will also
     * emit a trace activity that contains the QnA Maker results.
     *
     * @param context The Turn Context that contains the user question to be queried against your knowledge base.
     * @param options (Optional) The options for the QnA Maker knowledge base. If null, constructor option is used for this instance.
     */
    getAnswers(context, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryOptions = Object.assign({}, this._options, options);
            const question = context && context.activity ? context.activity.text : '';
            const trimmedQuestion = question ? question.trim() : '';
            if (trimmedQuestion.length > 0) {
                const answers = yield this.queryQnaService(this.endpoint, trimmedQuestion, queryOptions);
                const minScore = typeof queryOptions.scoreThreshold === 'number' ? queryOptions.scoreThreshold : 0.001;
                const sortedQnaAnswers = answers.filter((ans) => ans.score >= minScore).sort((a, b) => b.score - a.score);
                this.emitTraceInfo(context, sortedQnaAnswers);
                return sortedQnaAnswers;
            }
            return [];
        });
    }
    /**
     * Called internally to query the QnA Maker service.
     *
     * @remarks
     * This is exposed to enable better unit testing of the service.
     */
    callService(endpoint, question, top) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryQnaService(endpoint, question, { top });
        });
    }
    /**
     * Called internally to query the QnA Maker service.
     */
    queryQnaService(endpoint, question, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${endpoint.host}/knowledgebases/${endpoint.knowledgeBaseId}/generateanswer`;
            const headers = {};
            const isLegacyProtocol = endpoint.host.endsWith('v2.0') || endpoint.host.endsWith('v3.0');
            const queryOptions = Object.assign({}, this._options, options);
            if (isLegacyProtocol) {
                headers['Ocp-Apim-Subscription-Key'] = endpoint.endpointKey;
            }
            else {
                headers.Authorization = `EndpointKey ${endpoint.endpointKey}`;
            }
            headers['User-Agent'] = this.getUserAgent();
            const qnaResult = yield request({
                url: url,
                method: 'POST',
                headers: headers,
                json: Object.assign({ question: question }, queryOptions)
            });
            return qnaResult.answers.map((ans) => {
                ans.score = ans.score / 100;
                ans.answer = htmlentities.decode(ans.answer);
                if (ans.qnaId) {
                    ans.id = ans.qnaId;
                    delete ans.qnaId;
                }
                return ans;
            });
        });
    }
    getUserAgent() {
        const packageUserAgent = `${pjson.name}/${pjson.version}`;
        const platformUserAgent = `(${os.arch()}-${os.type()}-${os.release()}; Node.js,Version=${process.version})`;
        const userAgent = `${packageUserAgent} ${platformUserAgent}`;
        return userAgent;
    }
    /**
     * Emits a trace event detailing a QnA Maker call and its results.
     *
     * @param context Context for the current turn of conversation with the user.
     * @param answers Answers returned by QnA Maker.
     */
    emitTraceInfo(context, answers) {
        const traceInfo = {
            message: context.activity,
            queryResults: answers,
            knowledgeBaseId: this.endpoint.knowledgeBaseId,
            scoreThreshold: this._options.scoreThreshold,
            top: this._options.top,
            strictFilters: [{}],
            metadataBoost: [{}]
        };
        return context.sendActivity({
            type: 'trace',
            valueType: QNAMAKER_TRACE_TYPE,
            name: QNAMAKER_TRACE_NAME,
            label: QNAMAKER_TRACE_LABEL,
            value: traceInfo
        });
    }
}
exports.QnAMaker = QnAMaker;
//# sourceMappingURL=qnaMaker.js.map